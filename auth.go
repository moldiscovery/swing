package main

import (
	"bufio"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/credentials"
	"github.com/aws/aws-sdk-go/aws/session"
	"github.com/aws/aws-sdk-go/service/iam"
	"github.com/aws/aws-sdk-go/service/sts"
)

// Authorize user using saved credentials, if MFA devices are found
// for this user asks to pick device and input token
func Authorize(region string) (*session.Session, error) {
	creds, err := readCache()
	if err != nil {
		return nil, err
	}

	if creds != nil && creds.Expiration.After(time.Now().UTC()) {
		// Cache hit, user is still authenticated
		return session.Must(session.NewSession(
			&aws.Config{
				Region: aws.String(region),
				Credentials: credentials.NewStaticCredentialsFromCreds(
					credentials.Value{
						AccessKeyID:     creds.AccessKey,
						SecretAccessKey: creds.SecretAccessKey,
						SessionToken:    creds.SessionToken,
					},
				),
			},
		)), nil
	}

	// Region set here is overwritten if found in AWS shared credential file
	sess := session.Must(session.NewSession(&aws.Config{
		Region: aws.String(region),
	}))

	_, err = sess.Config.Credentials.Get()
	if err != nil {
		return nil, err
	}
	devices, err := getMFADevices(sess)
	if err != nil {
		return nil, err
	}

	var token string
	var device *iam.MFADevice

	if len(devices) > 1 {
		// Ask user which device
		device, err = getDevice(devices)
	} else if len(devices) == 1 {
		device = devices[0]
	} else {
		// No MFA, already authorized
		return sess, nil
	}

	// Ask user for token
	token, err = getToken(*device.SerialNumber)

	// Get new credentials
	svc := sts.New(sess)
	newCredentials, err := svc.GetSessionToken(
		&sts.GetSessionTokenInput{
			SerialNumber: device.SerialNumber,
			TokenCode:    aws.String(token),
		},
	)
	if err != nil {
		return nil, err
	}

	saveCache(&cachedCredentials{
		AccessKey:       *newCredentials.Credentials.AccessKeyId,
		SecretAccessKey: *newCredentials.Credentials.SecretAccessKey,
		SessionToken:    *newCredentials.Credentials.SessionToken,
		Expiration:      *newCredentials.Credentials.Expiration,
	})

	return session.Must(session.NewSession(
		&aws.Config{
			Region: aws.String(region),
			Credentials: credentials.NewStaticCredentialsFromCreds(
				credentials.Value{
					AccessKeyID:     *newCredentials.Credentials.AccessKeyId,
					SecretAccessKey: *newCredentials.Credentials.SecretAccessKey,
					SessionToken:    *newCredentials.Credentials.SessionToken,
				},
			),
		},
	)), nil
}

type cachedCredentials struct {
	AccessKey       string    `json:"accessKey"`
	SecretAccessKey string    `json:"secretAccessKey"`
	SessionToken    string    `json:"sessionToken"`
	Expiration      time.Time `json:"expiration"`
}

func cachePath() (string, error) {
	configDir, err := os.UserConfigDir()
	if err != nil {
		return "", fmt.Errorf("Can't find config directory: %v", err)
	}

	configDir = filepath.Join(configDir, "Swing")
	err = os.MkdirAll(configDir, os.ModePerm)
	if err != nil {
		return "", fmt.Errorf("Can't create config directory: %v", err)
	}

	return filepath.Join(configDir, "swing.conf"), nil
}

func readCache() (*cachedCredentials, error) {
	configPath, err := cachePath()
	if err != nil {
		return nil, err
	}

	configs, err := ioutil.ReadFile(configPath)
	if err != nil {
		if os.IsNotExist(err) {
			return nil, nil
		}
		return nil, fmt.Errorf("Error reading configs: %v", err)
	}

	var c *cachedCredentials
	err = json.Unmarshal(configs, &c)
	if err != nil {
		return nil, fmt.Errorf("Error parsing configs: %v", err)
	}

	return c, nil
}

func saveCache(c *cachedCredentials) error {
	configPath, err := cachePath()
	if err != nil {
		return err
	}

	data, err := json.Marshal(c)
	if err != nil {
		return fmt.Errorf("Can't convert credentials to json: %v", err)
	}

	// We ignore the error here, it would be obviously better if credentials
	// are saved to avoid asking a new token each time but we'll take the risk
	ioutil.WriteFile(configPath, data, os.ModePerm)

	return nil
}

// Gets list of MFA devices associated with the user's account
func getMFADevices(s *session.Session) ([]*iam.MFADevice, error) {
	svc := iam.New(s)

	userOut, err := svc.GetUser(&iam.GetUserInput{})
	if err != nil {
		return make([]*iam.MFADevice, 0),
			fmt.Errorf("Error requesting user name: %v", err)
	}

	mfaDevicesOut, err := svc.ListMFADevices(&iam.ListMFADevicesInput{
		UserName: userOut.User.UserName,
	})
	if err != nil {
		return make([]*iam.MFADevice, 0),
			fmt.Errorf("Error requesting MFA devices: %v", err)
	}

	return mfaDevicesOut.MFADevices, nil
}

// Keeps asking user for token generated by selected device
func getToken(mfaDevice string) (string, error) {
	reader := bufio.NewReader(os.Stdin)
	token := ""
	for {
		if token != "" {
			break
		}

		fmt.Printf("Enter token for device %s: ", mfaDevice)
		var err error = nil
		token, err = reader.ReadString('\n')
		if err != nil {
			return "", fmt.Errorf("Can't read token input: %v", err)
		}
		token = strings.TrimSpace(token)
	}
	return token, nil
}

// Keeps asking user to choose device for authentication
func getDevice(mfaDevices []*iam.MFADevice) (*iam.MFADevice, error) {
	reader := bufio.NewReader(os.Stdin)
	for i, device := range mfaDevices {
		fmt.Printf("%d) %s", i, *device.SerialNumber)
	}
	deviceIndex := -1
	for {
		if deviceIndex >= 0 && deviceIndex < len(mfaDevices) {
			break
		}

		fmt.Printf("Choose MFA device to authenticate [0-%d]: ", len(mfaDevices)-1)
		device, err := reader.ReadString('\n')
		if err != nil {
			return nil, fmt.Errorf("Can't read device input: %v", err)
		}
		deviceIndex, err = strconv.Atoi(device)
		if err != nil {
			return nil, fmt.Errorf("Can't parse device input: %v", err)
		}
	}

	return mfaDevices[deviceIndex], nil
}
