package main

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
	"strings"

	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/credentials"
	"github.com/aws/aws-sdk-go/aws/session"
	"github.com/aws/aws-sdk-go/service/iam"
	"github.com/aws/aws-sdk-go/service/sts"
)

// Authorize user using saved credentials, if MFA devices are found
// for this user asks to pick device and input token
func Authorize(region string) (*session.Session, error) {

	// Region set here is overwritten if found in AWS shared credential file
	sess := session.Must(session.NewSession(&aws.Config{
		Region: aws.String(region),
	}))
	// TODO: Check cache

	_, err := sess.Config.Credentials.Get()
	if err != nil {
		return nil, err
	}
	devices, err := getMFADevices(sess)
	if err != nil {
		return nil, err
	}

	var token string
	var device *iam.MFADevice

	if len(devices) > 1 {
		// Ask user which device
		device, err = getDevice(devices)
	} else if len(devices) == 1 {
		device = devices[0]
	} else {
		// No MFA, already authorized
		return sess, nil
	}

	// Ask user for token
	token, err = getToken(*device.SerialNumber)

	// Get new credentials
	svc := sts.New(sess)
	newCredentials, err := svc.GetSessionToken(
		&sts.GetSessionTokenInput{
			SerialNumber: device.SerialNumber,
			TokenCode:    aws.String(token),
		},
	)
	if err != nil {
		return nil, err
	}

	// TODO: Cache here

	return session.Must(session.NewSession(
		&aws.Config{
			Region: aws.String(region),
			Credentials: credentials.NewStaticCredentialsFromCreds(
				credentials.Value{
					AccessKeyID:     *newCredentials.Credentials.AccessKeyId,
					SecretAccessKey: *newCredentials.Credentials.SecretAccessKey,
					SessionToken:    *newCredentials.Credentials.SessionToken,
				},
			),
		},
	)), nil
}

// Gets list of MFA devices associated with the user's account
func getMFADevices(s *session.Session) ([]*iam.MFADevice, error) {
	svc := iam.New(s)

	userOut, err := svc.GetUser(&iam.GetUserInput{})
	if err != nil {
		return make([]*iam.MFADevice, 0),
			fmt.Errorf("Error requesting user name: %v", err)
	}

	mfaDevicesOut, err := svc.ListMFADevices(&iam.ListMFADevicesInput{
		UserName: userOut.User.UserName,
	})
	if err != nil {
		return make([]*iam.MFADevice, 0),
			fmt.Errorf("Error requesting MFA devices: %v", err)
	}

	return mfaDevicesOut.MFADevices, nil
}

// Keeps asking user for token generated by selected device
func getToken(mfaDevice string) (string, error) {
	reader := bufio.NewReader(os.Stdin)
	token := ""
	for {
		if token != "" {
			break
		}

		fmt.Printf("Enter token for device %s: ", mfaDevice)
		var err error = nil
		token, err = reader.ReadString('\n')
		if err != nil {
			return "", fmt.Errorf("Can't read token input: %v", err)
		}
		token = strings.TrimSpace(token)
	}
	return token, nil
}

// Keeps asking user to choose device for authentication
func getDevice(mfaDevices []*iam.MFADevice) (*iam.MFADevice, error) {
	reader := bufio.NewReader(os.Stdin)
	for i, device := range mfaDevices {
		fmt.Printf("%d) %s", i, *device.SerialNumber)
	}
	deviceIndex := -1
	for {
		if deviceIndex >= 0 && deviceIndex < len(mfaDevices) {
			break
		}

		fmt.Printf("Choose MFA device to authenticate [0-%d]: ", len(mfaDevices)-1)
		device, err := reader.ReadString('\n')
		if err != nil {
			return nil, fmt.Errorf("Can't read device input: %v", err)
		}
		deviceIndex, err = strconv.Atoi(device)
		if err != nil {
			return nil, fmt.Errorf("Can't parse device input: %v", err)
		}
	}

	return mfaDevices[deviceIndex], nil
}
